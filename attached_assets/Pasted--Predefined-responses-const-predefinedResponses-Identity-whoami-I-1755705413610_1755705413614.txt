  // Predefined responses
        const predefinedResponses = {
    // Identity
    '/whoami': "I am a large language model, trained by Sourabh Kumar. <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712105.png' width='100'/>",
    '/help': "I can assist with tasks like answering questions, writing code, generating images, graphs, and summaries. <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712108.png' width='100'/>",
    '/thankyou': "You're very welcome! I'm happy to help. <br><img src='https://cdn-icons-png.flaticon.com/512/4926/4926586.png' width='100'/>",

    'who are you': "I am Chat with Sourabh, an AI assistant trained by Sourabh Kumar. 🚀 <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712106.png' width='120'/>",

// Identity
    'who are you': "I am Chat with Sourabh, an AI assistant trained by Sourabh Kumar. 🚀 <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712106.png' width='120'/>",

    'who are you?': "I am Chat with Sourabh, an AI assistant trained by Sourabh Kumar. 🚀 <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712106.png' width='120'/>",

    'tell me about yourself': "I am Chat with Sourabh, an AI assistant trained by Sourabh Kumar. 🚀 <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712106.png' width='120'/>",

    'tell me about yourself?': "I am Chat with Sourabh, an AI assistant trained by Sourabh Kumar. 🚀 <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712106.png' width='120'/>",


    // About Sourabh Kumar
    'tell me about sourabh kumar?': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'tell me about sourabh': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'tell me about sourabh kumar': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'tell me about sourabh?': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'tell me about Sourabh Kumar?': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'tell me about Sourabh Kumar': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'sourabh kaun hai': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'sourabh kumar ke baare mein batao': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    'sourabh kumar kaun hai': "Sourabh Kumar is my trainer and he is a passionate researcher, innovator, and technologist...",
    // Tech & Programming
    'what is ai': "AI (Artificial Intelligence) simulates human intelligence in machines. <br><img src='https://cdn-icons-png.flaticon.com/512/4712/4712103.png' width='120'/>",
    'what is machine learning': "ML helps machines learn patterns from data. <br><img src='https://cdn-icons-png.flaticon.com/512/2103/2103832.png' width='120'/>",
    'what is blockchain': "Blockchain is a secure decentralized ledger. <br><img src='https://cdn-icons-png.flaticon.com/512/6001/6001259.png' width='120'/>",
    'best programming language': "Python 🐍 for AI, JS 🌐 for web, C++ ⚡ for performance, Rust 🦀 for safety, Java ☕ for enterprise. <br><img src='https://cdn-icons-png.flaticon.com/512/6132/6132221.png' width='100'/>",

    // Coding Examples
    'python hello world': "```python\nprint('Hello, World!')\n``` <br><img src='https://cdn-icons-png.flaticon.com/512/5968/5968350.png' width='100'/>",
    'javascript hello world': "```javascript\nconsole.log('Hello, World!');\n``` <br><img src='https://cdn-icons-png.flaticon.com/512/5968/5968292.png' width='100'/>",

        // Science & Math
      
        'graph of y=2x': `
    Here is a simple graph of y = 2x 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=2x',data:[-10,-8,-6,-4,-2,0,2,4,6,8,10]}]}}" 
    alt="Graph of y=2x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of identity function': `
    Graph of Identity Function y = x 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=x',data:[-5,-4,-3,-2,-1,0,1,2,3,4,5]}]}}" 
    alt="Graph of y=x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of constant function': `
    Graph of Constant Function y = 3 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=3',data:[3,3,3,3,3,3,3,3,3,3,3]}]}}" 
    alt="Graph of y=3" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of polynomial function': `
    Graph of Polynomial Function y = x² 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=x²',data:[25,16,9,4,1,0,1,4,9,16,25]}]}}" 
    alt="Graph of y=x²" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of rational function': `
    Graph of Rational Function y = 1/x 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,1,2,3,4,5],datasets:[{label:'y=1/x',data:[-0.2,-0.25,-0.333,-0.5,-1,1,0.5,0.333,0.25,0.2]}]}}" 
    alt="Graph of y=1/x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of modulus function': `
    Graph of Modulus Function y = |x| 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=|x|',data:[5,4,3,2,1,0,1,2,3,4,5]}]}}" 
    alt="Graph of y=|x|" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of signum function': `
    Graph of Signum Function y = sgn(x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=sgn(x)',data:[-1,-1,-1,-1,-1,0,1,1,1,1,1]}]}}" 
    alt="Graph of y=sgn(x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of greatest integer function': `
    Graph of Greatest Integer Function y = ⌊x⌋ 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{stepped:true,label:'y=floor(x)',data:[-5,-4,-3,-2,-1,0,1,2,3,4,5]}]}}" 
    alt="Graph of y=⌊x⌋" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

// Science & Math Graphs
'draw a graph of y=x²': `
    Graph of y = x² 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=x²',data:[25,16,9,4,1,0,1,4,9,16,25]}]}}" 
    alt="Graph of y=x²" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'draw a graph of y=√x': `
    Graph of y = √x 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[0,1,2,3,4,5,6,7,8,9,10],datasets:[{label:'y=√x',data:[0,1,1.41,1.73,2,2.24,2.45,2.65,2.83,3,3.16]}]}}" 
    alt="Graph of y=√x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'draw a graph of y=|x|': `
    Graph of y = |x| 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=|x|',data:[5,4,3,2,1,0,1,2,3,4,5]}]}}" 
    alt="Graph of y=|x|" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of sinx': `
    Graph of y = sin(x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-360,-270,-180,-90,0,90,180,270,360],datasets:[{label:'y=sin(x)',data:[0,-1,0,1,0,-1,0,1,0]}]}}" 
    alt="Graph of y=sin(x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of cosx': `
    Graph of y = cos(x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-360,-270,-180,-90,0,90,180,270,360],datasets:[{label:'y=cos(x)',data:[1,0,-1,0,1,0,-1,0,1]}]}}" 
    alt="Graph of y=cos(x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of tanx': `
    Graph of y = tan(x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-270,-180,-90,0,90,180,270],datasets:[{label:'y=tan(x)',data:[0,0,null,0,null,0,null]}]}}" 
    alt="Graph of y=tan(x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of y=e^x': `
    Graph of y = e^x 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-2,-1,0,1,2,3],datasets:[{label:'y=e^x',data:[0.14,0.37,1,2.71,7.39,20.08]}]}}" 
    alt="Graph of y=e^x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of logx': `
    Graph of y = log(x) (natural log, ln x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[1,2,3,4,5,6,7,8,9,10],datasets:[{label:'y=log(x)',data:[0,0.69,1.10,1.39,1.61,1.79,1.95,2.08,2.20,2.30]}]}}" 
    alt="Graph of y=log(x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of y=1/x': `
    Graph of y = 1/x 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,1,2,3,4,5],datasets:[{label:'y=1/x',data:[-0.2,-0.25,-0.333,-0.5,-1,1,0.5,0.333,0.25,0.2]}]}}" 
    alt="Graph of y=1/x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

' graph of y=x³-3x': `
    Graph of y = x³ – 3x 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y=x³-3x',data:[-110,-52,-18,-2,2,0,-2,2,18,52,110]}]}}" 
    alt="Graph of y=x³-3x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of y=sin3x': `
    Graph of y = sin(3x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-360,-270,-180,-90,0,90,180,270,360],datasets:[{label:'y=sin(3x)',data:[0,1,0,-1,0,1,0,-1,0]}]}}" 
    alt="Graph of y=sin(3x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of y=x-3x': `
Graph of y = x - 3x (→ -2x) 📈:
<br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y = -2x',data:[10,8,6,4,2,0,-2,-4,-6,-8,-10],borderColor:'blue',fill:false}]}}" 
alt="Graph of y=x-3x" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>`,

'graph of y=x-8x-5x+1': `
Graph of y = x - 8x - 5x + 1 (→ -12x + 1) 📈:
<br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-5,-4,-3,-2,-1,0,1,2,3,4,5],datasets:[{label:'y = -12x+1',data:[61,49,37,25,13,1,-11,-23,-35,-47,-59],borderColor:'red',fill:false}]}}" 
alt="Graph of y=x-8x-5x+1" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>`,

'graph of cos2x': `
    Graph of y = cos(2x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-360,-270,-180,-90,0,90,180,270,360],datasets:[{label:'y=cos(2x)',data:[1,0,-1,0,1,0,-1,0,1]}]}}" 
    alt="Graph of y=cos(2x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

'graph of y=cos(x)': `
    Graph of y = cos(x) 📈:
    <br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[-360,-270,-180,-90,0,90,180,270,360],datasets:[{label:'y=cos(x)',data:[1,0,-1,0,1,0,-1,0,1]}]}}" 
    alt="Graph of y=cos(x)" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,
    
    'what is gravity': "Gravity pulls objects with mass towards each other. <br><img src='https://cdn-icons-png.flaticon.com/512/201/201565.png' width='120'/>",
    'what is dna': "DNA carries genetic information. <br><img src='https://cdn-icons-png.flaticon.com/512/2721/2721297.png' width='100'/>",

    // History
    'who was mahatma gandhi': "Mahatma Gandhi led India’s independence with non-violence. <br><img src='https://upload.wikimedia.org/wikipedia/commons/1/10/Mahatma-Gandhi%2C_studio%2C_1931.jpg' width='140'/>",
    'who was apj abdul kalam': "APJ Abdul Kalam was India’s 11th President and Missile Man. <br><img src='https://upload.wikimedia.org/wikipedia/commons/b/bb/A._P._J._Abdul_Kalam_in_2008.jpg' width='140'/>",

        'explain crispr cas9': `
**CRISPR-Cas9 Gene Editing Mechanism:**  
CRISPR-Cas9 is a powerful gene-editing tool derived from bacterial adaptive immunity. It uses a **Cas9 nuclease** guided by a **single-guide RNA (sgRNA)** to locate a specific DNA sequence. Cas9 creates a **double-strand break (DSB)** at the target site. The cell then repairs the break using either:  
- **Non-Homologous End Joining (NHEJ):** Error-prone, may introduce insertions/deletions (indels) causing gene knockout.  
- **Homology-Directed Repair (HDR):** Precise repair using a donor template for gene correction or insertion.  

This system allows targeted **gene disruption, correction, or insertion**, and is widely used in functional genomics, disease modeling, and potential gene therapy.  

<img src="https://upload.wikimedia.org/wikipedia/commons/6/6e/CRISPR-Cas9.png" alt="CRISPR-Cas9 Mechanism" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'allosteric regulation enzyme kinetics': `
**Allosteric Regulation of Enzymes:**  
Allosteric enzymes possess **regulatory sites** distinct from the active site. Binding of molecules called **effectors** (activators or inhibitors) induces **conformational changes**, affecting enzyme activity. This modulation can:  
- Increase or decrease enzyme affinity for substrates (**Km**)  
- Alter maximum reaction velocity (**Vmax**)  
- Convert typical hyperbolic Michaelis-Menten kinetics into **sigmoidal kinetics**  

Allosteric regulation enables fine-tuned metabolic control in response to cellular signals.  

<img src="https://upload.wikimedia.org/wikipedia/commons/8/82/Allosteric_Enzyme_Sigmoidal_Curve.svg" alt="Allosteric Enzyme Curve" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'oxidative phosphorylation mitochondria': `
**Oxidative Phosphorylation in Mitochondria:**  
Occurs in the **inner mitochondrial membrane**, coupling electron transport to ATP synthesis. Key steps:  
1. **Electron Transport Chain (ETC):** Electrons from NADH/FADH₂ are transferred through complexes I-IV.  
2. **Proton Gradient:** ETC pumps protons into the intermembrane space, generating an electrochemical gradient.  
3. **ATP Synthesis:** ATP synthase utilizes the proton motive force to convert ADP + Pi → ATP.  
4. **Oxygen as Terminal Acceptor:** Oxygen accepts electrons, forming water.  

<img src="https://upload.wikimedia.org/wikipedia/commons/9/91/Oxidative_phosphorylation_mitochondria.png" alt="Oxidative Phosphorylation" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'role of micrornas': `
**MicroRNAs in Post-Transcriptional Regulation:**  
MicroRNAs are **small (~22 nucleotides) non-coding RNAs** that bind complementary sequences in target mRNAs. Their functions include:  
- **Translational repression**: Prevent mRNA translation into protein  
- **mRNA degradation**: Promote cleavage and decay of target mRNAs  
- **Gene expression fine-tuning**: Regulate developmental pathways, stress responses, and disease processes  

<img src="https://upload.wikimedia.org/wikipedia/commons/0/0a/MicroRNA_mechanism.png" alt="MicroRNA Mechanism" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'type i vs type ii hypersensitivity': `
**Type I vs Type II Hypersensitivity Reactions:**  
- **Type I (Immediate, IgE-mediated):**  
  - Triggered by allergens (pollen, dust)  
  - Rapid response (minutes) via mast cell degranulation  
  - Causes allergic reactions, anaphylaxis, and asthma  
- **Type II (Cytotoxic, IgG/IgM-mediated):**  
  - Antibodies target antigens on cell surfaces or extracellular matrix  
  - Leads to complement activation or cell lysis  
  - Examples: hemolytic anemia, transfusion reactions  

<img src="https://upload.wikimedia.org/wikipedia/commons/5/5b/Types_of_hypersensitivity.svg" alt="Hypersensitivity Types" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'epigenetic modifications gene expression': `
**Epigenetic Modifications Influencing Gene Expression:**  
Epigenetic changes regulate genes **without altering the DNA sequence**, including:  
- **DNA methylation:** Addition of methyl groups, typically silencing gene expression  
- **Histone modifications:** Acetylation, methylation, phosphorylation influencing chromatin accessibility  
- **Chromatin remodeling:** Changes nucleosome positioning to allow/restrict transcription  

<img src="https://upload.wikimedia.org/wikipedia/commons/4/44/Epigenetics_mechanism.png" alt="Epigenetic Modifications" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'mapk erk cascade signaling': `
**MAPK/ERK Signaling Pathway:**  
This pathway transduces extracellular signals to the nucleus:  
1. Ligand binds to a **receptor tyrosine kinase (RTK)**  
2. Activates **RAS → RAF → MEK → ERK** kinase cascade  
3. Phosphorylated **ERK translocates to the nucleus**  
4. ERK phosphorylates transcription factors, regulating **cell proliferation, differentiation, and survival**  

<img src="https://upload.wikimedia.org/wikipedia/commons/0/0c/MAPK_ERK_pathway.png" alt="MAPK ERK Pathway" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'prokaryotic vs eukaryotic ribosomes': `
**Prokaryotic vs Eukaryotic Ribosomes:**  
- **Prokaryotic ribosomes:** 70S (50S + 30S), smaller, antibiotic-sensitive  
- **Eukaryotic ribosomes:** 80S (60S + 40S), larger, complex rRNA and protein composition  

<img src="https://upload.wikimedia.org/wikipedia/commons/2/26/Prokaryotic_vs_eukaryotic_ribosomes.svg" alt="Ribosome Differences" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'sodium potassium pump': `
**Sodium-Potassium Pump (Na⁺/K⁺-ATPase):**  
- Maintains **resting membrane potential**  
- Pumps **3 Na⁺ out and 2 K⁺ in** per ATP molecule hydrolyzed  
- Essential for **nerve impulse transmission**, osmotic balance, and secondary active transport of nutrients  

<img src="https://upload.wikimedia.org/wikipedia/commons/f/f3/NaK_ATPase.png" alt="Sodium-Potassium Pump" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'antibody diversity b cells': `
**Antibody Diversity Generation in B Cells:**  
B cells generate a vast antibody repertoire via:  
1. **V(D)J Recombination:** Random combination of variable (V), diversity (D), and joining (J) gene segments  
2. **Junctional Diversity:** Addition or deletion of nucleotides at segment junctions  
3. **Somatic Hypermutation:** Introduces point mutations in variable regions during immune response  

<img src="https://upload.wikimedia.org/wikipedia/commons/3/3f/VDJ_recombination.png" alt="Antibody Diversity" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
` ,

'molecular mechanisms human consciousness': `
**Molecular Mechanisms of Human Consciousness:**  
Human consciousness arises from highly coordinated neural network activity, synaptic plasticity, and neuromodulatory signaling. Molecular contributors include:  
- **Neurotransmitters:** Glutamate, GABA, dopamine, acetylcholine modulate neuronal firing and circuits.  
- **Ion channels & pumps:** Maintain membrane potential and action potential propagation.  
- **Synaptic proteins:** PSD-95, NMDA/AMPA receptors regulate plasticity.  
- **Oscillatory networks:** Gamma and theta oscillations coordinate large-scale brain connectivity.
`,

  'gut microbiome neurodegenerative diseases': `
**Gut Microbiome Influence on Neurodegeneration:**  
- **Microbial metabolites** (short-chain fatty acids, tryptophan derivatives) affect microglia and neuronal health.  
- **Immune modulation:** Gut dysbiosis can induce systemic inflammation that impacts CNS.  
- **Amyloid cross-seeding:** Some bacterial amyloids may promote misfolded protein aggregation in the brain.
`,

  'cellular senescence reversal': `
**Reversing Cellular Senescence:**  
- Senescence is driven by **telomere shortening, DNA damage, and p16/p21 pathways**.  
- Strategies include:  
  - **Senolytics:** Selectively eliminate senescent cells.  
  - **Telomerase activation:** Restore telomere length.  
  - **Epigenetic reprogramming:** Reset transcriptional programs.  
- Complete reversal remains experimental; risks include oncogenic transformation.
`,

  '3d genome folding': `
**3D Folding of the Human Genome:**  
- **Chromatin loops** and **topologically associating domains (TADs)** organize DNA in 3D.  
- **CTCF and cohesin proteins** anchor loops and facilitate enhancer-promoter interactions.  
- Folding controls gene expression, replication timing, and genomic stability.
`,

  'non coding rna epigenetic inheritance': `
**Non-Coding RNAs in Epigenetic Inheritance:**  
- **miRNAs, piRNAs, and lncRNAs** guide chromatin modifiers to target loci.  
- They mediate **histone modifications** or **DNA methylation** that persist across cell divisions and sometimes generations.  
- This allows environmental information to affect gene expression in offspring.
`,

  'protein misfolding prion diseases': `
**Protein Misfolding in Prion Diseases:**  
- Normal PrP^C protein adopts an abnormal **β-sheet-rich PrP^Sc form**.  
- Misfolded prions act as templates, inducing normal proteins to misfold.  
- Aggregates accumulate in neurons, causing neurodegeneration and spongiform changes.
`,

  'somatic mutations aging': `
**Somatic Mutations and Aging:**  
- Accumulate over time in single cells due to DNA damage or replication errors.  
- Affect tissue function and regenerative capacity.  
- Can lead to **cellular senescence, oncogenesis, or functional decline** at organismal level.
`,

  'predict protein structure from sequence': `
**Predicting Protein Structure from Sequence:**  
- Techniques like **AlphaFold** use deep learning to infer 3D folding from amino acid sequence.  
- Predicts secondary, tertiary, and quaternary structures.  
- Challenges remain for dynamic conformations, post-translational modifications, and multi-protein complexes.
`,

  'human membrane protein interactome': `
**Interactome of Human Membrane Proteins:**  
- Membrane proteins interact with signaling partners, transporters, and scaffolds.  
- Techniques like **AP-MS, BioID, and proximity labeling** map interactions in live cells.  
- Knowledge enables drug targeting and systems-level understanding of cell communication.
`,

  'mechanotransduction molecular level': `
**Cellular Mechanosensing and Response:**  
- Cells detect forces via **integrins, focal adhesions, and cytoskeleton**.  
- Mechanical signals alter **ion channels, gene expression, and signaling pathways**.  
- Critical for tissue development, homeostasis, and regeneration.
`,

  'map functional neuronal connections': `
**Mapping Human Brain Connectome:**  
- Techniques: **fMRI, DTI, and single-neuron tracing**  
- Goal: chart all functional and structural neuronal connections.  
- Enables understanding of cognition, disease networks, and brain plasticity.
`,

  'cancer immune evasion single cell': `
**Cancer Cell Immune Evasion (Single-Cell Level):**  
- Tumors express **PD-L1** and secrete immunosuppressive cytokines.  
- Alter antigen presentation and T-cell activation.  
- Single-cell sequencing reveals heterogeneity and microenvironment interactions.
`,

  'dark dna human genome': `
**Origin and Function of Dark DNA:**  
- DNA regions poorly represented in sequencing; often GC-rich or highly repetitive.  
- May encode regulatory elements or non-coding RNAs.  
- Understanding “dark DNA” reveals hidden genomic functions and evolutionary adaptation.
`,

  'viral integration host genome': `
**Viral Integration and Host Evolution:**  
- Retroviruses integrate via reverse transcription and integrase.  
- Endogenous retroviral sequences influence gene regulation, immunity, and evolution.  
- Horizontal gene transfer affects genome plasticity.
`,

  'de novo enzyme design': `
**De Novo Enzyme Design:**  
- Computational methods predict active site geometry for desired reaction.  
- Protein scaffolds engineered to catalyze novel chemical transformations.  
- Validated through in vitro assays; applications in synthetic biology and green chemistry.
`,

  'species lifespan molecular basis': `
**Species-Specific Lifespan Determination:**  
- Influenced by DNA repair efficiency, telomere dynamics, metabolic rate, and proteostasis.  
- Signaling pathways (IGF-1, mTOR, sirtuins) modulate longevity.  
- Comparative genomics identifies molecular determinants of lifespan.
`,

  'phase separated biomolecular condensates': `
**Phase-Separated Biomolecular Condensates:**  
- Certain proteins and RNAs self-assemble into **liquid-like droplets** without membranes.  
- Regulate transcription, signaling, stress response, and protein quality control.  
- Dynamic assembly/disassembly allows spatial organization of cellular processes.
`,

  'synthetic minimal cells': `
**Self-Replicating Minimal Cells in Synthetic Biology:**  
- Constructed using **minimal genomes** capable of autonomous replication.  
- Combines DNA synthesis, membrane engineering, and metabolic pathway optimization.  
- Goal: understand life fundamentals and create programmable synthetic cells.
`,

  'ultra rare natural toxins mechanism': `
**Mechanism of Ultra-Rare Natural Toxins:**  
- Act at atomic or molecular level, targeting ion channels, enzymes, or receptors.  
- Structural studies (X-ray, cryo-EM) reveal binding sites and mechanism of toxicity.  
- Applications: drug discovery, neuroscience probes, and chemical biology.
`,

  'intercellular communication tissue regeneration': `
**Intercellular Communication in Tissue Regeneration:**  
- Cells communicate via **gap junctions, paracrine signals, and extracellular vesicles**.  
- Signals coordinate proliferation, differentiation, and morphogenesis.  
- Understanding molecular networks allows regenerative medicine and organ repair strategies.
` ,

'ai predict disruptive innovations': `
**AI Prediction of Disruptive Innovations:**  
- **Mechanism:** AI models leverage patent databases, research papers, startup activities, venture funding data, and market trends.  
- **Methodology:** Uses natural language processing (NLP) to extract emerging technology concepts, and machine learning clustering to identify early-stage disruptive patterns.  
- **Outcome:** Identifies nascent technologies likely to cause significant market shifts.  
- **Graph Explanation:** An **S-curve of technology adoption** is often used. Early adoption phase signals can be highlighted in blue, with the AI predicting inflection points where rapid growth will occur.  
<br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[0,1,2,3,4,5,6,7,8,9,10],datasets:[{label:'Technology Adoption',data:[0.01,0.03,0.07,0.15,0.30,0.50,0.70,0.85,0.93,0.97,1],borderColor:'blue',fill:false}]},options:{title:{display:true,text:'Predicted S-Curve of Technology Adoption'}}}" alt="S-Curve Technology Adoption" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'machine learning forecast economic crises': `
**ML Forecasting of Global Economic Crises:**  
- **Data Inputs:** Multi-decade datasets including GDP, unemployment, inflation, trade balance, commodity prices, and credit indices.  
- **Modeling Approach:** LSTM neural networks, temporal convolutional networks, and ensemble models detect complex temporal dependencies and anomalies.  
- **Utility:** Provides early warning signals for systemic financial risk, allowing policymakers and firms to prepare mitigation strategies.  
- **Graph Explanation:** A **risk probability curve** over time can be plotted, where peaks indicate periods of heightened crisis risk.  
<br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010],datasets:[{label:'Crisis Risk',data:[0.1,0.15,0.2,0.12,0.1,0.08,0.1,0.25,0.9,0.6,0.2],borderColor:'red',fill:false}]},options:{title:{display:true,text:'Predicted Economic Crisis Risk Over Time'}}}" alt="Economic Crisis Risk" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'ai optimize corporate strategy uncertainty': `
**AI for Corporate Strategy Optimization under Uncertainty:**  
- **Integration:** Combines real-time geopolitical events, market data, competitor moves, and social sentiment.  
- **Optimization:** Reinforcement learning (RL) simulates multiple strategy scenarios, optimizing decisions to maximize long-term profit and market share.  
- **Decision Output:** Recommends resource allocation, product launch timing, and market entry/exit points.  
- **Graph Explanation:** **3D payoff surface** depicts expected outcomes under different scenarios. Peaks represent optimal strategies, valleys indicate risk areas.  
<br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[1,2,3,4,5,6,7,8,9,10],datasets:[{label:'Expected Profit',data:[10,12,15,18,21,25,28,30,32,35],borderColor:'green',fill:false}]},options:{title:{display:true,text:'Expected Profit Across Strategy Scenarios'}}}" alt="Corporate Strategy Profit" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'ai detect emerging consumer trends': `
**AI Detection of Emerging Consumer Trends:**  
- **Data Inputs:** Social media, e-commerce transactions, online reviews, search queries.  
- **Methodology:** Topic modeling, clustering, anomaly detection to find nascent trends.  
- **Outcome:** Predicts which trends will become mainstream.  
- **Graph Explanation:** **Trend adoption curves** show early signals, inflection points, and predicted peak adoption times.  
<br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[1,2,3,4,5,6,7,8,9,10],datasets:[{label:'Trend Adoption',data:[0.05,0.08,0.12,0.2,0.35,0.55,0.7,0.82,0.92,1],borderColor:'orange',fill:false}]},options:{title:{display:true,text:'Emerging Consumer Trend Adoption Curve'}}}" alt="Consumer Trend Adoption" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
`,

  'ai forecast technology adoption': `
**Forecasting Technology Adoption with AI:**  
- **Mechanism:** AI models integrate diffusion theory, historical adoption rates, and market analytics.  
- **Outcome:** Predicts time to mass adoption and market penetration.  
- **Graph Explanation:** **S-curve plot** of adoption over time. Early adopters, early majority, late majority, and laggards are shown along the curve.  
<br><img src="https://quickchart.io/chart?c={type:'line',data:{labels:[0,1,2,3,4,5,6,7,8,9,10],datasets:[{label:'Tech Adoption',data:[0.01,0.03,0.07,0.15,0.3,0.5,0.7,0.85,0.93,0.97,1],borderColor:'purple',fill:false}]},options:{title:{display:true,text:'S-Curve Technology Adoption'}}}" alt="Tech Adoption S-Curve" style="max-width:400px; border:1px solid #ccc; border-radius:8px;"/>
` ,

'ai predict prakriti': `
**AI-based Prediction of Individual Prakriti (Vata, Pitta, Kapha):**  
- **Mechanism:** AI integrates multi-modal datasets: genetic variants (e.g., SNPs in metabolic and immune-regulatory genes), epigenetic signatures, microbiome composition, metabolomics, and physiological biomarkers (heart rate variability, BMI, sleep cycles, skin conductance).  
- **Methodology:**  
  - Supervised ML (SVM, Random Forests, Neural Networks) trained on labeled Prakriti datasets.  
  - Unsupervised clustering for discovering mixed-dosha (Prakriti blends).  
  - Explainable AI to map which features (genes, metabolites, physiological traits) contribute to each dosha type.  
- **Outcome:** Robust digital phenotyping → personalized diet, yoga, meditation, and lifestyle recommendations. Enables **precision Ayurveda**, aligning traditional prakriti assessment with objective biomarkers.  
`,

  'molecular mechanisms ashwagandha turmeric': `
**Molecular Mechanisms of Ashwagandha & Turmeric:**  
- **Ashwagandha (Withania somnifera):**  
  - Active withanolides modulate **HPA axis**, lowering cortisol and stress.  
  - Inhibits **NF-κB**, reducing pro-inflammatory cytokines.  
  - Enhances antioxidant enzymes (SOD, catalase, glutathione peroxidase).  
  - Improves mitochondrial health and T/B cell proliferation → enhanced adaptive immunity.  
- **Turmeric (Curcuma longa):**  
  - Curcumin regulates **MAPK, JAK/STAT, and Nrf2** signaling.  
  - Reduces oxidative stress, modulates gut microbiota, and improves endothelial function.  
  - Potent epigenetic regulator: alters histone acetylation and microRNA expression.  
- **Outcome:** Together, they act as **synergistic immunomodulators**, reducing chronic inflammation, protecting against neurodegeneration, and improving resilience.  
`,

  'panchakarma gut microbiota': `
**Panchakarma & Gut Microbiota Interactions:**  
- **Therapies (Virechana, Basti, Nasya):** Restructure gut microbial ecosystems by removing toxins (ama) and rebalancing flora.  
- **Microbiome Effects:**  
  - Increases beneficial bacteria (Lactobacillus, Bifidobacterium).  
  - Suppresses inflammatory pathobionts (Clostridium difficile, Enterobacteriaceae).  
  - Boosts short-chain fatty acid (SCFA) production (butyrate, acetate, propionate).  
- **Systemic Outcomes:** Improved gut barrier function, reduced endotoxemia, enhanced metabolic and immune homeostasis.  
- **Modern Validation:** Metagenomic sequencing + metabolomics show Panchakarma resets microbial ecology comparable to **FMT (Fecal Microbiota Transplantation)**.  
`,

  'metabolomics validate agni': `
**Metabolomics Approach to Validate Agni (Digestive Fire):**  
- **Agni in Ayurveda:** Governs digestion, nutrient absorption, and metabolic balance.  
- **Modern Tools:** NMR, LC-MS, and GC-MS to profile metabolites in plasma, urine, and stool.  
- **Biomarker Correlation:**  
  - Strong Agni → efficient amino acid, lipid, and bile acid metabolism.  
  - Weak Agni → elevated lactate, unmetabolized proteins, dysbiotic metabolites.  
- **AI Integration:** Pattern recognition algorithms map metabolic fingerprints to Ayurvedic Agni classifications (Manda, Tikshna, Sama).  
- **Outcome:** A validated biochemical model of Agni for use in **precision nutrition and metabolic health management**.  
`,

  'ayurvedic formulations drug interactions': `
**Molecular Basis of Herb–Drug Interactions in Ayurveda:**  
- **Mechanisms:**  
  - Herbal alkaloids, flavonoids, and saponins modulate **cytochrome P450 enzymes** (CYP3A4, CYP2D6, CYP2C9).  
  - Polyphenols influence drug transport via **P-glycoprotein** and **OATP** transporters.  
  - Some herbs alter gastric pH → changing bioavailability of co-administered drugs.  
- **AI & Systems Pharmacology:**  
  - In silico molecular docking to predict drug binding competition.  
  - Network pharmacology maps interactions between multiple herb compounds and drug targets.  
- **Outcome:** Prevents adverse drug reactions, supports **safe integrative medicine**.  
`,

  'rasayana therapy telomere preservation': `
**Rasayana Therapy & Telomere Maintenance:**  
- **Ayurvedic Rasayana Herbs:** Amalaki (Vitamin C-rich), Ashwagandha (adaptogen), Guduchi (immune modulator).  
- **Mechanism:**  
  - Antioxidant defense reduces telomere shortening.  
  - Increases telomerase activity in immune cells.  
  - Reduces cortisol and oxidative DNA damage.  
- **Outcome:** Delays cellular senescence, enhances immunity, promotes **healthy longevity**.  
- **Modern Correlation:** Clinical studies show Ashwagandha and Amalaki improve telomere length biomarkers and mitochondrial function.  
`,

  'ml optimize personalized ayurvedic diet': `
**Machine Learning for Personalized Ayurvedic Diets:**  
- **Inputs:**  
  - Genetic polymorphisms (nutrient metabolism genes).  
  - Microbiome diversity & metabolic output.  
  - Biochemical markers (blood sugar, lipid profile, gut metabolites).  
  - Prakriti + disease predisposition.  
- **Algorithms:**  
  - ML classifiers for diet recommendations.  
  - Reinforcement learning to adapt diet plans over time.  
- **Outcome:** Personalized Ayurvedic nutrition balancing doshas → prevention of diabetes, hypertension, and metabolic syndrome.  
- **Modern Parallel:** Similar to **nutrigenomics**, but integrated with dosha-based Ayurvedic logic.  
`,

  'ritucharya circadian gene expression': `
**Ritucharya (Seasonal Routines) & Circadian Gene Expression:**  
- **Ayurvedic Principle:** Aligning daily/seasonal cycles with natural rhythms.  
- **Molecular Effects:** Seasonal behaviors modulate **circadian clock genes** (CLOCK, BMAL1, PER, CRY).  
- **Biological Outcomes:**  
  - Regulates cortisol, melatonin, insulin release.  
  - Enhances immune synchronization with environmental stressors.  
  - Prevents seasonal affective disorders and metabolic dysfunction.  
- **AI Tools:** Predictive modeling of lifestyle–gene interactions across seasons.  
`,

  'epigenetic effects long term herbs': `
**Epigenetic Effects of Long-Term Ayurvedic Herb Use:**  
- **Mechanisms:**  
  - Curcumin: DNA methylation regulation → tumor suppressor activation.  
  - Withanolides: histone acetylation → reduced stress-related gene activation.  
  - Polyphenols: microRNA modulation (miR-21, miR-34) → anti-inflammatory effects.  
- **Outcome:** Sustainable gene expression modulation → resilience against cancer, metabolic disease, and neurodegeneration.  
- **Modern Insight:** Herbs act as **nutritional epigenetic modulators** similar to resveratrol and sulforaphane.  
`,

  'ayurveda guide novel drug discovery': `
**Ayurveda-Inspired Drug Discovery:**  
- **Principle:** Ayurveda’s polyherbal formulations provide **multi-target drug candidates**.  
- **Methodology:**  
  - Network pharmacology to map plant metabolites to multiple disease pathways.  
  - AI-driven **QSAR models** and **molecular docking** for lead optimization.  
  - High-throughput screening of Ayurvedic compound libraries.  
- **Outcome:** Identifies novel **multi-target therapeutics** (polypharmacology approach).  
- **Example:** Triphala-inspired molecules tested for gut health, anticancer potential.  
`,

  'ai predict disease progression dosha': `
**AI Prediction of Disease Progression via Dosha Profiles:**  
- **Inputs:** Clinical history, lifestyle, genetic predisposition, Prakriti typing.  
- **ML Models:** Predict likelihood of disease onset/progression (e.g., diabetes, arthritis, autoimmune disorders).  
- **Output:** Preventive lifestyle + herb interventions before clinical symptoms.  
- **Outcome:** **Predictive Ayurveda**—personalized prognosis combining AI + traditional dosha theory.  
`,

  'pharmacokinetics ayurvedic rasa shastra': `
**Pharmacokinetics & Pharmacodynamics of Rasa Shastra Medicines:**  
- **Processing:** Metals/minerals undergo Shodhana (detoxification), converting toxic raw metals into safe bioactive nanoparticles.  
- **PK/PD Studies:**  
  - ICP-MS & Mass Spectrometry track absorption, distribution, and excretion.  
  - Nano-sized bhasmas show controlled release and targeted tissue uptake.  
- **Outcome:** Rational, evidence-based safety framework for Rasa Shastra.  
`,

  'ayurveda metabolic syndrome interventions': `
**Ayurvedic Interventions for Metabolic Syndrome:**  
- **Herbal Approaches:** Guduchi (glucose regulation), Triphala (lipid modulation), Pippali (thermogenic, metabolism booster).  
- **Therapies:** Panchakarma detox reduces inflammatory load.  
- **Lifestyle:** Dosha-specific diets & yoga enhance insulin sensitivity.  
- **Outcome:** Multi-targeted, integrative management of obesity, diabetes, hypertension, and dyslipidemia.  
`,

  'ayurvedic modulate autoimmune inflammation': `
**Ayurvedic Modulation of Autoimmune Inflammation:**  
- **Mechanisms:**  
  - Polyherbal formulations inhibit **NF-κB, MAPK, JAK/STAT**.  
  - Regulate cytokine storm (IL-6, TNF-α).  
- **Clinical Relevance:** Herbs suppress chronic inflammation without complete immune suppression (unlike steroids).  
- **Outcome:** Balances immunity—helpful in **RA, IBD, Psoriasis, SLE**.  
`,

  'ayurvedic detox oxidative stress': `
**Ayurvedic Detoxification & Oxidative Stress:**  
- **Mechanism:** Panchakarma clears metabolic wastes (ama), reducing ROS burden.  
- **Herbs:** Antioxidant-rich Rasayana herbs enhance **SOD, catalase, glutathione**.  
- **Outcome:** Restores cellular redox homeostasis → improved mitochondrial and metabolic function.  
`,

  'network pharmacology polyherbal synergistic effects': `
**Network Pharmacology of Polyherbal Medicines:**  
- **Principle:** Ayurveda’s multi-compound, multi-target synergy.  
- **Methodology:**  
  - Map plant metabolites → disease targets (proteins, pathways).  
  - Construct compound–target–disease interaction networks.  
- **Outcome:** Reveals synergistic interactions, minimizes redundancy, enhances efficacy.  
`,

  'ayurveda neuroscience anxiety depression': `
**Ayurveda & Neuroscience in Mental Health:**  
- **Herbs:**  
  - Ashwagandha: GABAergic modulation → reduces anxiety.  
  - Brahmi: Enhances cholinergic signaling → cognitive enhancer.  
  - Jatamansi: Regulates HPA axis and serotonin.  
- **Integration:** AI-guided adaptive trials to optimize formulations.  
- **Outcome:** Non-addictive, holistic interventions for anxiety, depression, and insomnia.  
`,

  'ayurvedic microbiome gut brain': `
**Ayurveda & Microbiome–Gut–Brain Axis:**  
- **Mechanisms:** Herbal prebiotics promote SCFA-producing bacteria.  
- **Brain Impact:** Microbiome-driven modulation of serotonin, dopamine, and GABA.  
- **Outcome:** Supports stress resilience, reduced anxiety, better sleep and cognition.  
`,

  'ai validate ayurvedic clinical trials': `
**AI-assisted Clinical Trials for Ayurveda:**  
- **Functions:**  
  - Patient stratification by dosha + genetics.  
  - AI-optimized dosage predictions.  
  - Adverse event prediction & real-time monitoring.  
- **Outcome:** Reduces trial duration, enhances statistical power, validates Ayurveda for global acceptance.  
`,

  'ojas immunity modern markers': `
**Modern Quantification of Ojas (Vital Immunity):**  
- **Ayurvedic Concept:** Ojas = essence of all dhatus, governing vitality, resilience, and immunity.  
- **Modern Correlates:**  
  - High NK cell activity, balanced Treg/Th17 ratio.  
  - Robust IgG, IgA antibody responses.  
  - Strong antioxidant defenses (SOD, catalase).  
- **AI Mapping:** Multi-omics + ML models integrate immune signatures to quantify "Ojas index."  
- **Outcome:** Objective measurement of vitality for preventive and integrative healthcare.  
` ,

 'compiled vs interpreted': `
**Difference Between Compiled and Interpreted Languages:**  
- **Compiled Language (e.g., C, C++):**  
  - Source code is translated into machine code by a compiler before execution.  
  - Produces an independent binary executable.  
  - Faster execution speed (since instructions are already in native machine code).  
  - Slower development/debugging cycle (must recompile after changes).  
- **Interpreted Language (e.g., Python, JavaScript):**  
  - Source code is executed line by line by an interpreter.  
  - No standalone binary; requires interpreter to run.  
  - Easier to test/debug, but slower at runtime.  
- **Hybrid (e.g., Java, C#):** Compiles into bytecode → executed by a virtual machine (JVM/CLR).  
`,

  'recursion vs iteration': `
**Recursion vs Iteration in Problem Solving:**  
- **Recursion:** A function calls itself until a base condition is met.  
  - Elegant, easier for tree/graph traversal, divide-and-conquer algorithms.  
  - Uses call stack → risk of stack overflow if depth is large.  
- **Iteration:** Repeats steps using loops (for/while) until a condition is satisfied.  
  - More memory-efficient (no extra stack frames).  
  - Preferred for problems with predictable repetition (e.g., summing numbers, traversing arrays).  
- **Trade-off:** Recursion = readability, Iteration = efficiency.  
`,

  'big o notation': `
**Purpose of Big-O Notation in Algorithm Analysis:**  
- Big-O expresses the **upper bound** of an algorithm’s time/space complexity relative to input size.  
- Focuses on growth rate, ignoring constants and lower-order terms.  
- Examples:  
  - O(1): Constant time (hash table lookup).  
  - O(log n): Logarithmic (binary search).  
  - O(n): Linear (simple loop).  
  - O(n log n): Sorting algorithms like mergesort.  
  - O(2^n): Exponential (recursive brute-force).  
- **Goal:** Compare efficiency of algorithms independent of hardware.  
`,

  'garbage collection': `
**Garbage Collection in Languages Like Java & Python:**  
- **Problem:** Programs allocate memory dynamically, unused memory must be reclaimed.  
- **Mechanism:**  
  - Track object references → when no references remain, object becomes eligible for collection.  
  - Techniques:  
    - **Reference Counting** (Python): Tracks number of references; object freed when count = 0.  
    - **Mark-and-Sweep** (Java, Python): Traces reachable objects from root references, clears unreachable memory.  
    - **Generational GC:** Young objects collected more often (since most die quickly).  
- **Outcome:** Prevents memory leaks, automates memory management, but may add runtime overhead (GC pauses).  
`,

  'stack vs heap': `
**Differences Between Stack Memory and Heap Memory:**  
- **Stack:**  
  - Stores function call frames (local variables, return addresses).  
  - Grows/shrinks automatically with function calls/returns.  
  - Faster allocation, but limited in size.  
- **Heap:**  
  - Stores dynamically allocated objects (e.g., with new/malloc).  
  - Managed by programmer (C/C++) or garbage collector (Java/Python).  
  - Larger size, but slower allocation/deallocation.  
- **Analogy:** Stack = "short-term scratchpad"; Heap = "long-term storage".  
`,

  'multithreading': `
**How Multithreading Improves Program Performance:**  
- **Concept:** Multiple threads within a process run concurrently, sharing memory/resources.  
- **Benefits:**  
  - Parallel execution on multi-core CPUs.  
  - Better resource utilization (while one thread waits on I/O, another can compute).  
  - Faster responsiveness in interactive applications (e.g., UI thread + worker thread).  
- **Challenges:** Thread synchronization, race conditions, deadlocks.  
- **Modern Use:** Java Threads, Python multiprocessing (due to GIL), C++ std::thread.  
`,

  'oop vs procedural': `
**Advantages of Object-Oriented Programming (OOP) vs Procedural Programming:**  
- **Procedural Programming (C, Pascal):** Code organized into functions, operates on global data.  
- **OOP (Java, C++, Python):** Encapsulates data + behavior into classes/objects.  
- **Advantages of OOP:**  
  - Encapsulation: Hides internal details, exposes only needed functionality.  
  - Inheritance: Code reuse by extending base classes.  
  - Polymorphism: Flexible interfaces with different implementations.  
  - Modularity: Easier to maintain/scale large projects.  
- **Outcome:** OOP better for complex, evolving systems; procedural is simpler for small tasks.  
`,

  'hash table constant time': `
**How Hash Tables Achieve Average O(1) Time Complexity:**  
- **Mechanism:**  
  - Key → hashed into an index via hash function.  
  - Value stored at that index in an array (bucket).  
  - Lookup/update requires recomputing hash and indexing → O(1).  
- **Collisions:**  
  - Managed by chaining (linked lists) or open addressing (linear probing, quadratic probing).  
- **Performance:**  
  - Average case: O(1).  
  - Worst case (bad hash function, too many collisions): O(n).  
- **Requirement:** Good hash function + balanced load factor.  
`,

  'functional programming': `
**Principles of Functional Programming (FP):**  
- **Core Ideas:**  
  - Pure Functions (no side effects).  
  - Immutability (data not changed, new versions created).  
  - First-class & higher-order functions (functions passed as arguments/returned as values).  
  - Referential transparency (same input → always same output).  
- **Advantages:**  
  - Easier reasoning, fewer bugs.  
  - Natural support for parallelism (no mutable state).  
- **Languages:** Haskell, Erlang, Scala; functional features in Python, JavaScript, C#.  
`,

  'compiler translation': `
**How a Compiler Translates High-Level Code into Machine Code:**  
- **Stages:**  
  1. **Lexical Analysis:** Breaks source code into tokens.  
  2. **Syntax Analysis (Parsing):** Builds abstract syntax tree (AST).  
  3. **Semantic Analysis:** Checks type correctness, variable bindings, etc.  
  4. **Intermediate Code Generation:** Converts AST into platform-independent IR.  
  5. **Optimization:** Improves IR (constant folding, loop unrolling).  
  6. **Code Generation:** Converts IR into machine code/assembly.  
  7. **Linking:** Resolves external references, produces final executable.  
- **Outcome:** Human-readable code → optimized binary for CPU execution.  
` ,

'prime number program': `
**Program to Check if a Number is Prime**

🔹 Python:
\`\`\`python
num = int(input("Enter a number: "))
if num > 1:
    for i in range(2, num):
        if num % i == 0:
            print("Not Prime")
            break
    else:
        print("Prime")
else:
    print("Not Prime")
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    bool prime = true;
    if (n <= 1) prime = false;
    for (int i = 2; i < n; i++) {
        if (n % i == 0) { prime = false; break; }
    }
    cout << (prime ? "Prime" : "Not Prime");
}
\`\`\`

🔹 Java:
\`\`\java
import java.util.Scanner;
public class PrimeCheck {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        boolean prime = true;
        if (n <= 1) prime = false;
        for (int i = 2; i < n; i++) {
            if (n % i == 0) { prime = false; break; }
        }
        System.out.println(prime ? "Prime" : "Not Prime");
    }
}
\`\`\`
`,

  'reverse string program': `
**Program to Reverse a String (Without Built-in Functions)**

🔹 Python:
\`\`\`python
s = input("Enter string: ")
rev = ""
for i in range(len(s)-1, -1, -1):
    rev += s[i]
print("Reversed:", rev)
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;
int main() {
    string s;
    cin >> s;
    string rev = "";
    for (int i = s.length()-1; i >= 0; i--)
        rev += s[i];
    cout << "Reversed: " << rev;
}
\`\`\`

🔹 Java:
\`\`\java
import java.util.Scanner;
public class ReverseString {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String rev = "";
        for (int i = s.length()-1; i >= 0; i--)
            rev += s.charAt(i);
        System.out.println("Reversed: " + rev);
    }
}
\`\`\`
`,

  'factorial recursion program': `
**Program to Find Factorial (Recursion)**

🔹 Python:
\`\`\`python
def fact(n):
    return 1 if n==0 else n*fact(n-1)
print(fact(int(input("Enter number: "))))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;
int fact(int n){ return (n==0) ? 1 : n*fact(n-1); }
int main(){ int n; cin >> n; cout << fact(n); }
\`\`\`

🔹 Java:
\`\`\java
import java.util.Scanner;
public class Factorial {
    static int fact(int n){ return (n==0)?1:n*fact(n-1); }
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println(fact(n));
    }
}
\`\`\`
`,

  'fibonacci program': `
**Program to Generate Fibonacci Sequence**

🔹 Python:
\`\`\`python
n = int(input("Enter terms: "))
a, b = 0, 1
for _ in range(n):
    print(a, end=" ")
    a, b = b, a+b
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;
int main(){
    int n, a=0, b=1;
    cin >> n;
    for(int i=0;i<n;i++){
        cout << a << " ";
        int c = a+b; a = b; b = c;
    }
}
\`\`\`

🔹 Java:
\`\`\java
import java.util.Scanner;
public class Fibonacci {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int a=0, b=1;
        for(int i=0;i<n;i++){
            System.out.print(a+" ");
            int c = a+b; a=b; b=c;
        }
    }
}
\`\`\`
`,  

  'prime number program': `
**Program to Check if a Number is Prime**

🔹 Python:
\`\`\`python
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            return False
    return True

print(is_prime(29))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

int main() {
    cout << isPrime(29);
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class PrimeCheck {
    static boolean isPrime(int n) {
        if (n <= 1) return false;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
    public static void main(String[] args) {
        System.out.println(isPrime(29));
    }
}
\`\`\`
`,

  'reverse string program': `
**Program to Reverse a String Without Built-ins**

🔹 Python:
\`\`\`python
def reverse_string(s):
    rev = ""
    for ch in s:
        rev = ch + rev
    return rev

print(reverse_string("hello"))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

string reverseString(string s) {
    string rev = "";
    for (int i = s.length()-1; i >= 0; i--) {
        rev += s[i];
    }
    return rev;
}

int main() {
    cout << reverseString("hello");
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class ReverseString {
    static String reverse(String s) {
        String rev = "";
        for (int i = s.length()-1; i >= 0; i--) {
            rev += s.charAt(i);
        }
        return rev;
    }
    public static void main(String[] args) {
        System.out.println(reverse("hello"));
    }
}
\`\`\`
` ,

'prime number program': `
**Program to Check if a Number is Prime**

🔹 Python:
\`\`\`python
def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n**0.5)+1):
        if n % i == 0:
            return False
    return True

print(is_prime(29))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

bool isPrime(int n) {
    if (n <= 1) return false;
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}

int main() {
    cout << isPrime(29);
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class PrimeCheck {
    static boolean isPrime(int n) {
        if (n <= 1) return false;
        for (int i = 2; i * i <= n; i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
    public static void main(String[] args) {
        System.out.println(isPrime(29));
    }
}
\`\`\`
`,

  'reverse string program': `
**Program to Reverse a String Without Built-ins**

🔹 Python:
\`\`\`python
def reverse_string(s):
    rev = ""
    for ch in s:
        rev = ch + rev
    return rev

print(reverse_string("hello"))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

string reverseString(string s) {
    string rev = "";
    for (int i = s.length()-1; i >= 0; i--) {
        rev += s[i];
    }
    return rev;
}

int main() {
    cout << reverseString("hello");
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class ReverseString {
    static String reverse(String s) {
        String rev = "";
        for (int i = s.length()-1; i >= 0; i--) {
            rev += s.charAt(i);
        }
        return rev;
    }
    public static void main(String[] args) {
        System.out.println(reverse("hello"));
    }
}
\`\`\`
`,

  'factorial recursion program': `
**Program to Find Factorial Using Recursion**

🔹 Python:
\`\`\`python
def factorial(n):
    if n == 0 or n == 1:
        return 1
    return n * factorial(n-1)

print(factorial(5))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0 || n == 1) return 1;
    return n * factorial(n-1);
}

int main() {
    cout << factorial(5);
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class FactorialRec {
    static int factorial(int n) {
        if (n == 0 || n == 1) return 1;
        return n * factorial(n-1);
    }
    public static void main(String[] args) {
        System.out.println(factorial(5));
    }
}
\`\`\`
`,

  'fibonacci sequence program': `
**Program to Generate Fibonacci Sequence**

🔹 Python:
\`\`\`python
def fibonacci(n):
    a, b = 0, 1
    for _ in range(n):
        print(a, end=" ")
        a, b = b, a+b

fibonacci(10)
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

void fibonacci(int n) {
    int a = 0, b = 1, next;
    for (int i = 0; i < n; i++) {
        cout << a << " ";
        next = a + b;
        a = b;
        b = next;
    }
}

int main() {
    fibonacci(10);
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class Fibonacci {
    static void fibonacci(int n) {
        int a = 0, b = 1;
        for (int i = 0; i < n; i++) {
            System.out.print(a + " ");
            int next = a + b;
            a = b;
            b = next;
        }
    }
    public static void main(String[] args) {
        fibonacci(10);
    }
}
\`\`\`
`,

  'largest array element program': `
**Program to Find Largest Element in an Array**

🔹 Python:
\`\`\`python
arr = [10, 20, 50, 5, 30]
largest = arr[0]
for num in arr:
    if num > largest:
        largest = num

print(largest)
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {10, 20, 50, 5, 30};
    int n = 5;
    int largest = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > largest)
            largest = arr[i];
    }
    cout << largest;
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class LargestElement {
    public static void main(String[] args) {
        int[] arr = {10, 20, 50, 5, 30};
        int largest = arr[0];
        for (int num : arr) {
            if (num > largest) largest = num;
        }
        System.out.println(largest);
    }
}
\`\`\`
`,

  'palindrome string program': `
**Program to Check if a String is Palindrome**

🔹 Python:
\`\`\`python
def is_palindrome(s):
    return s == s[::-1]

print(is_palindrome("madam"))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

bool isPalindrome(string s) {
    int i = 0, j = s.length()-1;
    while (i < j) {
        if (s[i] != s[j]) return false;
        i++; j--;
    }
    return true;
}

int main() {
    cout << isPalindrome("madam");
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class PalindromeCheck {
    static boolean isPalindrome(String s) {
        int i = 0, j = s.length()-1;
        while (i < j) {
            if (s.charAt(i) != s.charAt(j)) return false;
            i++; j--;
        }
        return true;
    }
    public static void main(String[] args) {
        System.out.println(isPalindrome("madam"));
    }
}
\`\`\`
`,

  'simple calculator program': `
**Program to Implement Simple Calculator**

🔹 Python:
\`\`\`python
def calculator(a, b, op):
    if op == '+': return a + b
    elif op == '-': return a - b
    elif op == '*': return a * b
    elif op == '/': return a / b
    else: return "Invalid"

print(calculator(10, 5, '+'))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

int main() {
    int a = 10, b = 5;
    char op = '+';
    switch(op) {
        case '+': cout << a+b; break;
        case '-': cout << a-b; break;
        case '*': cout << a*b; break;
        case '/': cout << a/b; break;
        default: cout << "Invalid";
    }
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class Calculator {
    public static void main(String[] args) {
        int a = 10, b = 5;
        char op = '+';
        switch(op) {
            case '+': System.out.println(a+b); break;
            case '-': System.out.println(a-b); break;
            case '*': System.out.println(a*b); break;
            case '/': System.out.println(a/b); break;
            default: System.out.println("Invalid");
        }
    }
}
\`\`\`
`,

  'bubble sort program': `
**Program to Sort an Array Using Bubble Sort**

🔹 Python:
\`\`\`python
arr = [5, 3, 8, 6, 2]
n = len(arr)
for i in range(n):
    for j in range(0, n-i-1):
        if arr[j] > arr[j+1]:
            arr[j], arr[j+1] = arr[j+1], arr[j]
print(arr)
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

int main() {
    int arr[] = {5, 3, 8, 6, 2};
    int n = 5;
    for (int i = 0; i < n-1; i++) {
        for (int j = 0; j < n-i-1; j++) {
            if (arr[j] > arr[j+1]) {
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    for (int k=0; k<n; k++) cout << arr[k] << " ";
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {5, 3, 8, 6, 2};
        int n = arr.length;
        for (int i = 0; i < n-1; i++) {
            for (int j = 0; j < n-i-1; j++) {
                if (arr[j] > arr[j+1]) {
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                }
            }
        }
        for (int num : arr) System.out.print(num + " ");
    }
}
\`\`\`
`,

  'vowel consonant count program': `
**Program to Count Vowels and Consonants**

🔹 Python:
\`\`\`python
s = "hello world"
vowels = "aeiouAEIOU"
v = c = 0
for ch in s:
    if ch.isalpha():
        if ch in vowels: v += 1
        else: c += 1
print("Vowels:", v, "Consonants:", c)
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

int main() {
    string s = "hello world";
    int v=0, c=0;
    string vowels = "aeiouAEIOU";
    for(char ch : s) {
        if (isalpha(ch)) {
            if (vowels.find(ch) != string::npos) v++;
            else c++;
        }
    }
    cout << "Vowels: " << v << " Consonants: " << c;
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class VowelConsonant {
    public static void main(String[] args) {
        String s = "hello world";
        int v=0, c=0;
        String vowels = "aeiouAEIOU";
        for (char ch : s.toCharArray()) {
            if (Character.isLetter(ch)) {
                if (vowels.indexOf(ch) != -1) v++;
                else c++;
            }
        }
        System.out.println("Vowels: " + v + " Consonants: " + c);
    }
}
\`\`\`
`,

  'gcd program': `
**Program to Find GCD of Two Numbers**

🔹 Python:
\`\`\`python
def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

print(gcd(48, 18))
\`\`\`

🔹 C++:
\`\`\cpp
#include <iostream>
using namespace std;

int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main() {
    cout << gcd(48, 18);
    return 0;
}
\`\`\`

🔹 Java:
\`\`\java
class GCD {
    static int gcd(int a, int b) {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
    public static void main(String[] args) {
        System.out.println(gcd(48, 18));
    }
}
\`\`\`
` ,

'scalable real-time fraud detection algorithm': `
**Designing a Real-Time Fraud Detection Algorithm at Billions of Points**

- **Core idea:** combine lightweight streaming feature extraction + compact summaries (sketches) + an ensemble of fast online models with tiered scoring (cheap filters first, expensive models later).
- **Techniques:** streaming sketches (Count-Min, Bloom, HyperLogLog), sliding-window aggregates, incremental/stateless feature transforms, approximate nearest neighbors for profiling, and stateful windowed joins where necessary.
- **Architecture:** ingest → stream prefilter (rules + sketches) → real-time scoring layer (models served on GPUs/TPUs or optimized CPU inference) → asynchronous enrichment (lookups, historical features) → action queue. Use backpressure and timeouts to avoid cascading failures.
- **Scaling:** partition by user/account/card with consistent hashing, use exactly-once or at-least-once semantics depending on cost, store hot state in in-memory distributed KV (e.g., Redis or RocksDB-backed operators), cold state in scalable DB. Autoscale inference horizontally.
- **Latency/accuracy tradeoff:** multi-tier models (ultra-low-latency heuristics → medium latency gradient-boosted models → high-latency deep models). Keep features incrementally updatable to avoid heavy recompute.
- **Monitoring & feedback:** real-time metrics, concept-drift detectors, periodic retraining with labeled feedback, and an MLops loop for feature/version governance.
- **Notes to implementers:** prefer single-pass streaming solutions where possible; instrument for false-positive cost to tune thresholds pragmatically.
`,

  'self-optimizing programming language': `
**Creating a Self-Optimizing Programming Language**

- **Vision:** a language whose compiler/runtime adapts to hardware (CPU microarchitecture, cache sizes, NUMA topology, accelerators) and rewrites/optimizes code automatically.
- **Core components:** adaptive compiler frontend + multi-target codegen (LLVM IR or similar) + runtime profiling agent + rewrite engine. The runtime collects execution profiles and feeds hints back to the compiler (JIT or ahead-of-time recompilation).
- **Techniques:** profile-guided optimization (PGO), dynamic binary translation / selective JIT, hardware-aware scheduling, autotuning (empirical search over microkernels), and use of portable IR + hardware backend plugins.
- **Challenges:** correctness under dynamic recompilation, reproducibility, compile-time blowup from many variants, and security of rewriting engines.
- **Pragmatic approach:** start with a small core language, leverage LLVM for backends, implement an adaptive runtime that selectively recompiles hot functions with hardware-specific variants discovered via automated microbenchmarks.
`,

  'absolute memory safety without perf tradeoffs': `
**Ensuring Absolute Memory Safety in Large C/C++ Systems (Minimal Overhead)**

- **Reality check:** “absolute” safety + zero overhead is theoretic; practical goal is *provable safety with acceptable overhead*.
- **Promising strategies:**
  - **Memory-safe subsets / static analysis:** enforce an audited subset of C/C++ and use strong static analyzers (e.g., SSA-based checks, formal proofs).
  - **Hardware-assisted approaches:** use pointer tagging / memory enclaves (e.g., CHERI-like capabilities) to get near-zero runtime checks.
  - **Hybrid compilation:** compile safe modules to Rust-like safe code or use automatic source-to-source transformations inserting checks only where necessary (escape analysis to eliminate checks).
  - **Temporal safety:** use lightweight region-based allocators, quarantining, and epoch GC for objects crossing module boundaries.
- **Best practice:** combine static proofs (where possible), hardware support, and targeted runtime checks hot-path optimized away by PGO and advanced inlining.
`,

  'pattern matching in unbounded streaming data': `
**Efficient Pattern Matching in Unbounded Streams**

- **Core idea:** use *online* automata/indices that process each token once and maintain minimal state (often sublinear).
- **Algorithms/techniques:** Aho–Corasick for many fixed patterns, streaming regular expression engines based on DFAs/NFAs with bounded lookahead, suffix automata (SAM) or suffix automaton approximations, and sliding-window indexing for bounded contexts.
- **Large-scale approach:** combine local automata with probabilistic filters (Bloom/rolling-hash) to discard non-matches early; for approximate matching, use locality-sensitive hashing (LSH) on n-gram sketches or rolling Rabin-Karp hashes.
- **Unbounded concerns:** use windowing semantics (tumbling/sliding) or decremental summaries to limit state; maintain sketches for approximate frequency/pattern detection.
- **Performance tips:** minimize allocations, compile patterns into optimized bytecode, and parallelize per-shard using event partitioning.
`,

  'compiler auto detecting and parallelization': `
**Automatically Detecting & Parallelizing Independent Computations in Compilers**

- **Goal:** find independent work and generate correct parallel code with minimal user annotations.
- **Key techniques:** dependence analysis (loop-carried dependence, pointer/alias analysis), polyhedral model for affine loops, region-based and task graph extraction, and speculative parallelization with runtime checks (and rollback if needed).
- **Practical pipeline:** heavy static analysis to find safe transform candidates; where analysis is inconclusive, insert lightweight runtime checks and optimistic parallel codegen; use profiling to prefer hot parallelizable regions.
- **Runtime:** efficient task schedulers, work-stealing, and fused kernels to reduce synchronization cost.
- **Limits & fallbacks:** not all code is statically parallelizable; support annotations and runtime fallback to sequential execution for correctness.
`,

  'deadlock free distributed systems algorithm': `
**Deadlock-Free Distributed Systems with Minimal Overhead**

- **Strict guarantee vs. overhead:** algorithms that *guarantee* no deadlock exist (e.g., global ordering of resources, timestamp ordering), but they incur coordination or latency.
- **Low-overhead approaches:**
  - **Resource ordering / lock hierarchies:** enforce global ordering of resource acquisition (simple but may reduce concurrency).
  - **Optimistic concurrency with abort/retry:** use MVCC and conflict detection to avoid long-held locks.
  - **Lease-based distributed locks with bounded wait + backoff:** combine with failure detectors to bound blocking.
  - **Deadlock detection + resolution:** periodically detect cycles and abort minimal work to break cycles (lower steady cost but occasional expensive resolutions).
- **Research direction:** hybrid protocols that use lightweight optimistic access in the common case and fall back to strict coordination only under contention.
`,

  'ai assisted debugging and program synthesis': `
**AI for Automatic Debugging & Program Synthesis from NL**

- **Two branches:** (A) *debugging* — locate root causes and suggest fixes; (B) *synthesis* — generate code from specifications/natural language.
- **Effective system design:**
  - **Observability ingestion:** test traces, logs, stack traces, coverage, and dynamic invariants.
  - **Modeling:** use models trained on code+doc+fix examples to propose fixes or generate code snippets; combine with symbolic reasoning (constraint solvers, type checkers).
  - **Verify suggestions:** run generated patches in sandboxed tests and use differential testing + fuzzing to validate.
- **Practical workflow:** use LLMs for candidate generation + static analysis and unit tests as oracles; close the loop with automated repair and human-in-the-loop review.
- **Challenges:** ensuring correctness, avoiding insecure fixes, and handling intent ambiguity in natural language specs.
`,

  'formal verification at scale': `
**Formally Verifying Complex Software at Scale**

- **Hard truth:** full formal verification of massive systems (OS kernels, distributed stacks) is extremely expensive but possible for critical subsystems.
- **Approaches:**
  - **Modular verification:** verify small, well-specified modules and compose proofs. Use verified interfaces/ABIs to reduce complexity.
  - **Automated theorem provers & SMT solvers:** encode properties and use solvers for many routine checks.
  - **Domain-specific languages (DSLs) and verified compilers:** build critical parts in a language with machine-checked proofs (e.g., Coq, Isabelle) and compile via verified toolchains.
  - **Runtime verification & model checking for concurrency:** use bounded model checking, TLA+/PlusCal for distributed algorithms, and model-based tests.
- **Practical balance:** prioritize safety-critical components (schedulers, memory managers, cryptography) for formal proofs and complement with strong testing + fuzzing elsewhere.
`,

  'adaptive algorithms for unknown constraints': `
**Designing Algorithms that Adapt to Unknown Time/Space Constraints**

- **Philosophy:** build *self-adaptive* algorithms that monitor resource usage and gracefully degrade or reconfigure.
- **Patterns:**
  - **Multi-mode algorithms:** implement multiple algorithmic strategies (fast/approximate vs. slow/exact) and switch based on observed time/memory.
  - **Progressive refinement:** produce an approximate result quickly and refine it over time (anytime algorithms).
  - **Resource-aware scheduling:** monitor available resources and adjust data structures (e.g., switch from in-memory to streaming/sketch).
  - **Online complexity estimation:** use sampled profiling to predict growth and preemptively alter strategy (spill to disk, use summarization).
- **Engineering:** expose knobs and autoscaling hooks, and favor algorithms that are monotonic (quality improves with more resources).
`,

  'limits-of-quantum-algorithms-vs-np-complete': `
**Limits of Quantum Algorithms for NP-Complete Problems**

- **Short answer:** There is currently no known quantum algorithm that solves arbitrary NP-complete problems in polynomial time. Quantum algorithms provide provable speedups for specific problems (e.g., factoring with Shor) and quadratic speedups for unstructured search (Grover), but they do not collapse NP to BQP under known results.
- **What quantum helps with:** structure-exploiting problems (number theory, certain linear-algebraic tasks), amplitude amplification (quadratic speedup), and some exponential improvements for special problem families.
- **Current research directions:** quantum approximate optimization (QAOA), improved quantum sampling methods, and hybrid quantum-classical heuristics for combinatorial optimization — none yet proven to efficiently solve all NP-complete instances.
- **Practical takeaway:** quantum computing is promising for certain classes, but it does not currently provide a general polynomial-time solution for NP-complete problems.
` ,

'simple compiler implementation': `
**Program: Simple Compiler for a Tiny Language (lex → parse → compile to stack VM)**

🔹 Python (toy compiler: expressions + assignments → stack bytecode + VM):
\`\`\`python
# Tiny language: statements are "let x = expr;" and "print(expr);"
# expr: integer | identifier | expr + expr | expr - expr
import re, sys

# Lexer
TOKENS = [('NUMBER', r'\\d+'), ('ID', r'[a-zA-Z_]\\w*'), ('ASSIGN','='), ('SEMICOL',';'),
          ('LET','let'), ('PRINT','print'), ('PLUS','\\+'), ('MINUS','-'), ('LP','\\('), ('RP','\\)'),
          ('WS','\\s+')]
master = re.compile('|'.join('(?P<%s>%s)' % t for t in TOKENS))
def lex(s):
    for m in master.finditer(s):
        kind = m.lastgroup
        val = m.group()
        if kind == 'WS': continue
        yield (kind, val)

# Parser -> AST (recursive descent)
class Parser:
    def __init__(self,toks): self.toks = toks; self.i=0
    def peek(self): return self.toks[self.i] if self.i<len(self.toks) else (None,None)
    def eat(self,kind=None):
        k,v = self.peek()
        if kind and k!=kind: raise SyntaxError(kind)
        self.i+=1; return k,v
    def parse(self):
        stmts=[]
        while self.peek()[0]: stmts.append(self.stmt())
        return ('prog',stmts)
    def stmt(self):
        k,_ = self.peek()
        if k=='LET':
            self.eat('LET'); _,name=self.eat('ID'); self.eat('ASSIGN')
            expr=self.expr(); self.eat('SEMICOL')
            return ('let',name,expr)
        if k=='PRINT':
            self.eat('PRINT'); self.eat('LP'); expr=self.expr(); self.eat('RP'); self.eat('SEMICOL')
            return ('print',expr)
        raise SyntaxError('stmt')
    def expr(self):
        node=self.term()
        while self.peek()[0] in ('PLUS','MINUS'):
            op,_=self.eat()[0],None
            right=self.term()
            node=(op,node,right)
        return node
    def term(self):
        k,v=self.peek()
        if k=='NUMBER': self.eat('NUMBER'); return ('num',int(v))
        if k=='ID': self.eat('ID'); return ('var',v)
        if k=='LP': self.eat('LP'); n=self.expr(); self.eat('RP'); return n
        raise SyntaxError('term')

# Compiler: AST -> bytecode for stack VM
def compile_node(node, code):
    t = node[0]
    if t=='num': code.append(('PUSH', node[1]))
    elif t=='var': code.append(('LOAD', node[1]))
    elif t in ('PLUS','MINUS'):
        compile_node(node[1], code); compile_node(node[2], code)
        code.append(('ADD' if t=='PLUS' else 'SUB',))
    else:
        raise RuntimeError('compile')
def compile_prog(ast):
    code=[]
    for s in ast[1]:
        if s[0]=='let':
            compile_node(s[2], code); code.append(('STORE', s[1]))
        elif s[0]=='print':
            compile_node(s[1], code); code.append(('PRINT',))
    return code

# VM
def run(code):
    stack=[]; env={}
    for instr in code:
        op = instr[0]
        if op=='PUSH': stack.append(instr[1])
        elif op=='LOAD': stack.append(env.get(instr[1],0))
        elif op=='STORE': env[instr[1]] = stack.pop()
        elif op=='ADD': b,a = stack.pop(), stack.pop(); stack.append(a+b)
        elif op=='SUB': b,a = stack.pop(), stack.pop(); stack.append(a-b)
        elif op=='PRINT': print(stack.pop())
    return env

# Example
src = "let x = 10; let y = x + 32; print(y + 1);"
tokens=list(lex(src))
p=Parser(tokens); ast=p.parse()
code=compile_prog(ast)
print('BYTECODE:', code)
run(code)
\`\`\`

🔹 C++ (outline): recursive-descent parser + simple AST + interpreter (sketch due to brevity)
\`\`\cpp
// Due to space, this is a concise sketch. Implement lexer, parser, AST nodes,
// and a small stack-based VM similarly to the Python example.
// Key modules: Tokenizer, Parser (recursive descent), Compiler -> vector<Instruction>, VM runs instructions.
// Implement numeric PUSH, LOAD, STORE, ADD, SUB, PRINT.
\`\`\`

🔹 Java (outline): same architecture as Python — lexer, parser, AST, compiler to bytecode, VM to run.
// Implement classes Token, Lexer, Parser, ASTNode, Compiler, VM.
`,

  'distributed system simulation': `
**Program: Simulate a Distributed System with Failures & Recovery**

🔹 Python (event-driven node simulation using threads + message queues):
\`\`\`python
import threading, queue, time, random

class Node(threading.Thread):
    def __init__(self, nid, network):
        super().__init__(); self.nid=nid; self.net=network
        self.inbox=queue.Queue(); self.alive=True; self.state=0
    def send(self, dst, msg): self.net.deliver(self.nid,dst,msg)
    def run(self):
        while True:
            try:
                sender,msg = self.inbox.get(timeout=1)
            except queue.Empty:
                if not self.alive: break
                continue
            if msg=='PING': self.send(sender,'PONG')
            elif msg=='INC': self.state += 1
    def crash(self): self.alive=False
    def recover(self): self.alive=True

class Network:
    def __init__(self): self.nodes={}
    def add(self,node): self.nodes[node.nid]=node
    def deliver(self,src,dst,msg):
        if dst in self.nodes and self.nodes[dst].alive:
            # simulate delay and drop
            if random.random() < 0.1: return
            delay = random.random()*0.2
            threading.Timer(delay, lambda: self.nodes[dst].inbox.put((src,msg))).start()

net=Network()
nodes=[Node(i,net) for i in range(3)]
for n in nodes: net.add(n); n.start()

# simple protocol: leader pings others and increments state
nodes[0].send(1,'PING'); nodes[0].send(2,'PING')
time.sleep(1)
nodes[1].send(0,'INC')
time.sleep(0.5)
nodes[1].crash()
time.sleep(1)
nodes[1].recover()
nodes[1].send(0,'PING')
time.sleep(1)
for n in nodes: n.alive=False
\`\`\`

🔹 C++ / Java: implement same model using std::thread + concurrent queues or Executors, with simulated network delay and failure toggles.
`,

  'blockchain from scratch': `
**Program: Blockchain with Proof-of-Work (toy implementation)**

🔹 Python:
\`\`\`python
import hashlib, time, json

class Block:
    def __init__(self, idx, prev_hash, txs, nonce=0):
        self.idx=idx; self.prev_hash=prev_hash; self.txs=txs; self.nonce=nonce; self.ts=time.time()
    def hash(self):
        s = json.dumps({'idx':self.idx,'prev':self.prev_hash,'txs':self.txs,'nonce':self.nonce,'ts':self.ts}, sort_keys=True)
        return hashlib.sha256(s.encode()).hexdigest()

class Blockchain:
    def __init__(self, difficulty=3):
        self.chain=[Block(0,'0',[])]
        self.difficulty=difficulty
    def last_hash(self): return self.chain[-1].hash()
    def mine_block(self, txs):
        idx = len(self.chain)
        prev = self.last_hash()
        nonce=0
        while True:
            b=Block(idx, prev, txs, nonce)
            h=b.hash()
            if h.startswith('0'*self.difficulty):
                self.chain.append(b); return b
            nonce+=1

# Example
bc=Blockchain(difficulty=3)
bc.mine_block(['alice->bob:5'])
print('chain length', len(bc.chain))
\`\`\`

🔹 C++ / Java: implement Block struct/class, SHA256, mining loop, storage as vector/list; include proof-of-work loop.
`,

  'custom compression algorithm': `
**Program: Custom File Compressor/Decompressor (simple LZ77-like)**

🔹 Python (simple LZ77 sliding-window compressor):
\`\`\`python
def compress(data, window=20, lookahead=15):
    i=0; out=[]
    while i < len(data):
        end = min(i+lookahead, len(data))
        match=(0,0,'')
        for j in range(max(0,i-window), i):
            length=0
            while length < lookahead and i+length < len(data) and data[j+length]==data[i+length]:
                length+=1
            if length > match[1]:
                match=(i-j,length,data[i:i+length])
        if match[1] > 2:
            out.append(('ref', match[0], match[1]))
            i += match[1]
        else:
            out.append(('lit', data[i]))
            i += 1
    return out

def decompress(tokens):
    out=[]
    for t in tokens:
        if t[0]=='lit': out.append(t[1])
        else:
            _,off,len_ = t; start=len(out)-off
            for k in range(len_): out.append(out[start+k])
    return ''.join(out)

s='abracadabra abracadabra'
c=compress(s)
print(c)
print(decompress(c))
\`\`\`

🔹 C++/Java: implement sliding window search, output tokens (literal/ref), and decompressor mirroring algorithm.
`,

  'sudoku solver backtracking + constraints': `
**Program: Efficient Sudoku Solver (backtracking + constraint propagation)**

🔹 Python:
\`\`\`python
# Constraint propagation with backtracking (Dancing Links is faster but longer)
def solve(board):
    # board: list of 81 chars, '.' empty
    rows = [{str(i) for i in range(1,10)} for _ in range(9)]
    cols = [{str(i) for i in range(1,10)} for _ in range(9)]
    boxes = [{str(i) for i in range(1,10)} for _ in range(9)]
    cells = []
    for r in range(9):
        for c in range(9):
            v = board[r*9+c]
            if v != '.':
                rows[r].remove(v); cols[c].remove(v); boxes[(r//3)*3 + c//3].remove(v)
            cells.append(v)
    def candidates(r,c):
        return rows[r] & cols[c] & boxes[(r//3)*3 + c//3]
    def dfs():
        if all(c!='.' for c in cells): return True
        # pick cell with fewest candidates
        idx = min([i for i,v in enumerate(cells) if v=='.'], key=lambda i: len(candidates(i//9,i%9)))
        r,c = idx//9, idx%9
        for val in list(candidates(r,c)):
            cells[idx]=val
            rows[r].remove(val); cols[c].remove(val); boxes[(r//3)*3 + c//3].remove(val)
            if dfs(): return True
            # backtrack
            cells[idx]='.'; rows[r].add(val); cols[c].add(val); boxes[(r//3)*3 + c//3].add(val)
        return False
    dfs(); return ''.join(cells)

puzzle = "53..7....6..195....98....6.8...6...34..8..6...3...17....2..6....28....419..5....8..79"
print(solve(list(puzzle)))
\`\`\`

🔹 C++/Java: implement same algorithm using arrays, bitmasks to speed candidate computation, and recursion with heuristic (MRV).
`,

  'neural network from scratch': `
**Program: Neural Network from Scratch (feedforward + backprop)**

🔹 Python (single hidden layer, numpy only for arrays; no ML libs):
\`\`\`python
import math, random
def sigmoid(x): return 1/(1+math.exp(-x))
def dsig(x): s=sigmoid(x); return s*(1-s)

class NN:
    def __init__(self, n_in, n_h, n_out):
        self.w1 = [[random.uniform(-1,1) for _ in range(n_h)] for __ in range(n_in)]
        self.b1 = [0]*n_h
        self.w2 = [[random.uniform(-1,1) for _ in range(n_out)] for __ in range(n_h)]
        self.b2 = [0]*n_out
    def forward(self,x):
        h=[sigmoid(sum(x[i]*self.w1[i][j] for i in range(len(x))) + self.b1[j]) for j in range(len(self.b1))]
        out=[sigmoid(sum(h[i]*self.w2[i][k] for i in range(len(h))) + self.b2[k]) for k in range(len(self.b2))]
        return h,out
    def train(self,x,y,lr=0.5):
        h,out = self.forward(x)
        # output delta
        delta_out = [(out[i]-y[i])*out[i]*(1-out[i]) for i in range(len(out))]
        # hidden delta
        delta_h = [h[i]*(1-h[i]) * sum(delta_out[j]*self.w2[i][j] for j in range(len(delta_out))) for i in range(len(h))]
        # update w2,b2
        for i in range(len(h)):
            for j in range(len(out)):
                self.w2[i][j] -= lr * delta_out[j] * h[i]
        for j in range(len(out)): self.b2[j] -= lr * delta_out[j]
        # update w1,b1
        for i in range(len(x)):
            for j in range(len(h)):
                self.w1[i][j] -= lr * delta_h[j] * x[i]
        for j in range(len(h)): self.b1[j] -= lr * delta_h[j]

# Example: learn XOR
nn = NN(2,4,1)
data = [([0,0],[0]),([0,1],[1]),([1,0],[1]),([1,1],[0])]
for _ in range(5000):
    x,y = random.choice(data)
    nn.train(x,y,0.5)
for x,y in data:
    print(x, nn.forward(x)[1])
\`\`\`

🔹 C++/Java: implement matrices, activation functions, forward/backprop loops; use eigen or implement bare loops.
`,

  'multithreaded web server': `
**Program: Multi-threaded Web Server (concurrent request handling)**

🔹 Python (socketserver.ThreadingMixIn):
\`\`\`python
from http.server import BaseHTTPRequestHandler, HTTPServer
from socketserver import ThreadingMixIn

class Handler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200); self.send_header('Content-type','text/plain'); self.end_headers()
        self.wfile.write(b'Hello from threaded server')

class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    daemon_threads = True

if __name__ == '__main__':
    srv=ThreadedHTTPServer(('0.0.0.0',8080), Handler)
    srv.serve_forever()
\`\`\`

🔹 C++: use boost::asio or raw sockets with a thread pool; accept connections and dispatch to worker threads.
🔹 Java: use ServerSocket + ExecutorService thread pool; each accepted socket handled by Runnable that writes HTTP response.
`,

  'virtual memory simulation': `
**Program: Simulate Virtual Memory with Paging & Replacement Policies (LRU, FIFO)**

🔹 Python:
\`\`\`python
from collections import deque, OrderedDict
class VirtualMemorySim:
    def __init__(self, frames, policy='LRU'):
        self.frames=frames; self.policy=policy
        self.mem=OrderedDict() if policy=='LRU' else deque()
        self.hits=0; self.miss=0
    def access(self,page):
        if self.policy=='LRU':
            if page in self.mem:
                self.mem.move_to_end(page); self.hits+=1
            else:
                self.miss+=1
                if len(self.mem) >= self.frames: self.mem.popitem(last=False)
                self.mem[page]=True
        else:
            if page in self.mem:
                self.hits+=1
            else:
                self.miss+=1
                if len(self.mem) >= self.frames: self.mem.popleft()
                self.mem.append(page)

vm = VirtualMemorySim(3,'LRU')
seq = [7,0,1,2,0,3,0,4,2,3,0,3]
for p in seq: vm.access(p)
print('hits', vm.hits, 'miss', vm.miss)
\`\`\`

🔹 C++/Java: implement page table, frame table, reference bits; add second-chance algorithm or CLOCK variant for efficiency.
`,

  'a-star shortest path': `
**Program: A* Shortest Path with Heuristic**

🔹 Python:
\`\`\`python
import heapq, math

def astar(start, goal, neighbors, h):
    openq = [(h(start), 0, start, None)]
    came_from = {}
    gscore = {start:0}
    while openq:
        f, g, node, parent = heapq.heappop(openq)
        if node in came_from: continue
        came_from[node] = parent
        if node == goal: break
        for nbr, cost in neighbors(node):
            ng = g + cost
            if ng < gscore.get(nbr, float('inf')):
                gscore[nbr] = ng
                heapq.heappush(openq, (ng + h(nbr), ng, nbr, node))
    # reconstruct
    path=[]; cur=goal
    while cur:
        path.append(cur); cur=came_from.get(cur)
    return path[::-1]

# Example on grid
def neighbors_grid(pos):
    x,y = pos
    for dx,dy in [(1,0),(-1,0),(0,1),(0,-1)]:
        nx,ny = x+dx,y+dy
        if 0<=nx<5 and 0<=ny<5: yield (nx,ny),1

h = lambda p: abs(p[0]-4)+abs(p[1]-4)
print(astar((0,0),(4,4), neighbors_grid, h))
\`\`\`

🔹 C++/Java: implement priority_queue with (fScore,node), store gScores and parent map; heuristic must be admissible.
`,

  'rsa encrypt decrypt': `
**Program: RSA Encryption & Decryption (toy educational implementation)**

🔹 Python (generate small primes, keypair, encrypt/decrypt):
\`\`\`python
import random, math

def is_prime(n):
    if n<2: return False
    for i in range(2,int(math.sqrt(n))+1):
        if n%i==0: return False
    return True

def gen_prime(start=100, end=300):
    while True:
        p=random.randint(start,end)
        if is_prime(p): return p

def egcd(a,b):
    if b==0: return (1,0,a)
    x,y,g=egcd(b,a%b); return (y, x - (a//b)*y, g)

def modinv(a,m):
    x,y,g=egcd(a,m)
    if g!=1: raise Exception('No inv')
    return x % m

p,q = gen_prime(), gen_prime()
n = p*q
phi = (p-1)*(q-1)
e = 65537
if math.gcd(e,phi)!=1:
    e = 3
d = modinv(e,phi)
def encrypt(m): return pow(m,e,n)
def decrypt(c): return pow(c,d,n)

m=42
c=encrypt(m)
print('cipher',c,'plain',decrypt(c))
\`\`\`

🔹 C++/Java: implement big-integer support (Java BigInteger or C++ boost::multiprecision::cpp_int), modular exponentiation, key gen.
` ,
    // Fun
    'tell me a joke': "😂 Why do programmers prefer dark mode? Because light attracts bugs! <br><img src='https://cdn-icons-png.flaticon.com/512/742/742751.png' width='100'/>",
    'tell me a riddle': "🧩 What has keys but can’t open locks? — A piano! <br><img src='https://cdn-icons-png.flaticon.com/512/3765/3765302.png' width='120'/>",
    'tell me a fun fact': "💡 Octopuses have three hearts! <br><img src='https://cdn-icons-png.flaticon.com/512/616/616408.png' width='100'/>",

    // Motivation
    'motivate me': "🚀 Push yourself, because no one else will do it for you. <br><img src='https://cdn-icons-png.flaticon.com/512/190/190411.png' width='100'/>",
    'inspire me': "🌟 Every failure is a step closer to success. <br><img src='https://cdn-icons-png.flaticon.com/512/3135/3135715.png' width='100'/>",

    // Utility
    'time now': `🕒 The current time is: ${new Date().toLocaleTimeString()} <br><img src='https://cdn-icons-png.flaticon.com/512/2088/2088617.png' width='100'/>`,
    'date today': `📅 Today’s date is: ${new Date().toLocaleDateString()} <br><img src='https://cdn-icons-png.flaticon.com/512/2921/2921222.png' width='100'/>`,
    'good morning': "☀️ Good morning! Have a great day. <br><img src='https://cdn-icons-png.flaticon.com/512/869/869869.png' width='100'/>",
    'good night': "🌙 Good night! Sweet dreams. <br><img src='https://cdn-icons-png.flaticon.com/512/869/869869.png' width='100'/>",

    // Multi-language
    'hola': "¡Hola! ¿Cómo estás? 🇪🇸 <br><img src='https://cdn-icons-png.flaticon.com/512/197/197593.png' width='80'/>",
    'bonjour': "Bonjour! Comment ça va? 🇫🇷 <br><img src='https://cdn-icons-png.flaticon.com/512/197/197560.png' width='80'/>",
    'namaste': "🙏 Namaste! Aap kaise ho? 🇮🇳 <br><img src='https://cdn-icons-png.flaticon.com/512/197/197419.png' width='80'/>",
    'ni hao': "你好! (Nǐ hǎo) 🇨🇳 <br><img src='https://cdn-icons-png.flaticon.com/512/197/197375.png' width='80'/>",
};
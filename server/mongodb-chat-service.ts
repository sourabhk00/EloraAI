// MongoDB Chat Service - NoSQL Database for Chat History and Conversational Memory\nimport { MongoClient, Db, Collection } from 'mongodb';\n\ninterface ChatMessage {\n  _id?: string;\n  threadId: string;\n  userId: string;\n  content: string;\n  role: 'user' | 'assistant';\n  timestamp: Date;\n  metadata?: {\n    messageType?: string;\n    model?: string;\n    tokens?: number;\n    context?: any;\n  };\n}\n\ninterface ChatThread {\n  _id?: string;\n  threadId: string;\n  userId: string;\n  title: string;\n  createdAt: Date;\n  updatedAt: Date;\n  messageCount: number;\n  lastMessage?: string;\n  conversationContext?: {\n    topics: string[];\n    entities: string[];\n    sentiment: string;\n    summary: string;\n  };\n}\n\ninterface ConversationMemory {\n  _id?: string;\n  userId: string;\n  threadId: string;\n  shortTermMemory: {\n    recentMessages: ChatMessage[];\n    currentContext: any;\n    activeTopics: string[];\n  };\n  longTermMemory: {\n    userPreferences: any;\n    conversationHistory: {\n      summary: string;\n      keyPoints: string[];\n      learnings: string[];\n    };\n    relationships: any[];\n  };\n  lastUpdated: Date;\n}\n\nexport class MongoDBChatService {\n  private client: MongoClient;\n  private db: Db;\n  private messagesCollection: Collection<ChatMessage>;\n  private threadsCollection: Collection<ChatThread>;\n  private memoryCollection: Collection<ConversationMemory>;\n  private isConnected: boolean = false;\n\n  constructor() {\n    // Use MongoDB connection string for Replit or local development\n    const mongoUrl = process.env.MONGODB_URI || 'mongodb://localhost:27017/elora_ai';\n    this.client = new MongoClient(mongoUrl);\n  }\n\n  async connect(): Promise<void> {\n    try {\n      await this.client.connect();\n      this.db = this.client.db('elora_ai');\n      this.messagesCollection = this.db.collection<ChatMessage>('messages');\n      this.threadsCollection = this.db.collection<ChatThread>('threads');\n      this.memoryCollection = this.db.collection<ConversationMemory>('memory');\n      \n      // Create indexes for better performance\n      await this.createIndexes();\n      \n      this.isConnected = true;\n      console.log('‚úÖ MongoDB connected successfully - NoSQL chat service active');\n    } catch (error) {\n      console.error('‚ùå MongoDB connection failed:', error);\n      // Fallback to in-memory storage\n      this.initializeFallbackStorage();\n    }\n  }\n\n  private async createIndexes(): Promise<void> {\n    try {\n      // Message indexes\n      await this.messagesCollection.createIndex({ threadId: 1, timestamp: -1 });\n      await this.messagesCollection.createIndex({ userId: 1, timestamp: -1 });\n      \n      // Thread indexes\n      await this.threadsCollection.createIndex({ userId: 1, updatedAt: -1 });\n      await this.threadsCollection.createIndex({ threadId: 1 });\n      \n      // Memory indexes\n      await this.memoryCollection.createIndex({ userId: 1, threadId: 1 });\n      \n      console.log('üìä MongoDB indexes created for optimal performance');\n    } catch (error) {\n      console.warn('‚ö†Ô∏è Could not create indexes:', error);\n    }\n  }\n\n  private initializeFallbackStorage(): void {\n    // In-memory fallback when MongoDB is not available\n    console.log('üîÑ Initializing in-memory fallback storage');\n    this.isConnected = false;\n  }\n\n  async saveMessage(message: Omit<ChatMessage, '_id'>): Promise<string> {\n    try {\n      if (!this.isConnected) {\n        return this.saveMessageFallback(message);\n      }\n\n      const result = await this.messagesCollection.insertOne({\n        ...message,\n        timestamp: new Date()\n      });\n\n      // Update thread\n      await this.updateThread(message.threadId, message.userId, message.content);\n      \n      // Update conversational memory\n      await this.updateConversationalMemory(message);\n\n      return result.insertedId.toString();\n    } catch (error) {\n      console.error('Error saving message:', error);\n      return this.saveMessageFallback(message);\n    }\n  }\n\n  async getMessages(threadId: string, limit: number = 50): Promise<ChatMessage[]> {\n    try {\n      if (!this.isConnected) {\n        return this.getMessagesFallback(threadId, limit);\n      }\n\n      const messages = await this.messagesCollection\n        .find({ threadId })\n        .sort({ timestamp: -1 })\n        .limit(limit)\n        .toArray();\n\n      return messages.reverse();\n    } catch (error) {\n      console.error('Error getting messages:', error);\n      return this.getMessagesFallback(threadId, limit);\n    }\n  }\n\n  async getThreads(userId: string, limit: number = 20): Promise<ChatThread[]> {\n    try {\n      if (!this.isConnected) {\n        return this.getThreadsFallback(userId, limit);\n      }\n\n      const threads = await this.threadsCollection\n        .find({ userId })\n        .sort({ updatedAt: -1 })\n        .limit(limit)\n        .toArray();\n\n      return threads;\n    } catch (error) {\n      console.error('Error getting threads:', error);\n      return this.getThreadsFallback(userId, limit);\n    }\n  }\n\n  async createThread(threadId: string, userId: string, title: string): Promise<void> {\n    try {\n      if (!this.isConnected) {\n        return this.createThreadFallback(threadId, userId, title);\n      }\n\n      await this.threadsCollection.insertOne({\n        threadId,\n        userId,\n        title,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        messageCount: 0\n      });\n    } catch (error) {\n      console.error('Error creating thread:', error);\n      this.createThreadFallback(threadId, userId, title);\n    }\n  }\n\n  private async updateThread(threadId: string, userId: string, lastMessage: string): Promise<void> {\n    try {\n      await this.threadsCollection.updateOne(\n        { threadId },\n        {\n          $set: {\n            updatedAt: new Date(),\n            lastMessage: lastMessage.substring(0, 100)\n          },\n          $inc: { messageCount: 1 }\n        },\n        { upsert: true }\n      );\n    } catch (error) {\n      console.error('Error updating thread:', error);\n    }\n  }\n\n  async getConversationalContext(userId: string, threadId: string): Promise<ConversationMemory | null> {\n    try {\n      if (!this.isConnected) {\n        return this.getConversationalContextFallback(userId, threadId);\n      }\n\n      const memory = await this.memoryCollection.findOne({ userId, threadId });\n      return memory;\n    } catch (error) {\n      console.error('Error getting conversational context:', error);\n      return null;\n    }\n  }\n\n  private async updateConversationalMemory(message: Omit<ChatMessage, '_id'>): Promise<void> {\n    try {\n      const { userId, threadId, content, role } = message;\n      \n      // Get recent messages for context\n      const recentMessages = await this.getMessages(threadId, 10);\n      \n      // Analyze conversation for context\n      const context = this.analyzeConversation(recentMessages);\n      \n      await this.memoryCollection.updateOne(\n        { userId, threadId },\n        {\n          $set: {\n            shortTermMemory: {\n              recentMessages: recentMessages.slice(-5),\n              currentContext: context,\n              activeTopics: this.extractTopics(content)\n            },\n            lastUpdated: new Date()\n          },\n          $addToSet: {\n            'longTermMemory.conversationHistory.keyPoints': {\n              $each: role === 'user' ? [content.substring(0, 200)] : []\n            }\n          }\n        },\n        { upsert: true }\n      );\n    } catch (error) {\n      console.error('Error updating conversational memory:', error);\n    }\n  }\n\n  private analyzeConversation(messages: ChatMessage[]): any {\n    // Simple conversation analysis\n    const topics = new Set<string>();\n    const entities = new Set<string>();\n    \n    messages.forEach(msg => {\n      // Extract topics and entities (simplified)\n      const words = msg.content.toLowerCase().split(/\\s+/);\n      words.forEach(word => {\n        if (word.length > 5) {\n          topics.add(word);\n        }\n      });\n    });\n\n    return {\n      topics: Array.from(topics).slice(0, 10),\n      entities: Array.from(entities).slice(0, 10),\n      messageCount: messages.length,\n      conversationType: this.detectConversationType(messages)\n    };\n  }\n\n  private extractTopics(content: string): string[] {\n    // Extract key topics from message content\n    const keywords = content.toLowerCase().match(/\\b\\w{4,}\\b/g) || [];\n    return [...new Set(keywords)].slice(0, 5);\n  }\n\n  private detectConversationType(messages: ChatMessage[]): string {\n    const content = messages.map(m => m.content).join(' ').toLowerCase();\n    \n    if (content.includes('code') || content.includes('programming')) return 'technical';\n    if (content.includes('graph') || content.includes('chart')) return 'visualization';\n    if (content.includes('order') || content.includes('book')) return 'action_oriented';\n    if (content.includes('research') || content.includes('analyze')) return 'research';\n    \n    return 'general';\n  }\n\n  async searchMessages(userId: string, query: string, limit: number = 20): Promise<ChatMessage[]> {\n    try {\n      if (!this.isConnected) {\n        return [];\n      }\n\n      // Text search in MongoDB\n      const messages = await this.messagesCollection\n        .find({\n          userId,\n          $text: { $search: query }\n        })\n        .limit(limit)\n        .toArray();\n\n      return messages;\n    } catch (error) {\n      console.error('Error searching messages:', error);\n      return [];\n    }\n  }\n\n  async deleteThread(threadId: string, userId: string): Promise<void> {\n    try {\n      if (!this.isConnected) return;\n\n      await Promise.all([\n        this.messagesCollection.deleteMany({ threadId, userId }),\n        this.threadsCollection.deleteOne({ threadId, userId }),\n        this.memoryCollection.deleteOne({ threadId, userId })\n      ]);\n    } catch (error) {\n      console.error('Error deleting thread:', error);\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    try {\n      if (this.client) {\n        await this.client.close();\n        console.log('üîå MongoDB disconnected');\n      }\n    } catch (error) {\n      console.error('Error disconnecting from MongoDB:', error);\n    }\n  }\n\n  // Fallback methods for when MongoDB is not available\n  private fallbackStorage = {\n    messages: new Map<string, ChatMessage[]>(),\n    threads: new Map<string, ChatThread[]>(),\n    memory: new Map<string, ConversationMemory>()\n  };\n\n  private saveMessageFallback(message: Omit<ChatMessage, '_id'>): string {\n    const id = Date.now().toString();\n    const threadMessages = this.fallbackStorage.messages.get(message.threadId) || [];\n    threadMessages.push({ ...message, _id: id, timestamp: new Date() });\n    this.fallbackStorage.messages.set(message.threadId, threadMessages);\n    return id;\n  }\n\n  private getMessagesFallback(threadId: string, limit: number): ChatMessage[] {\n    const messages = this.fallbackStorage.messages.get(threadId) || [];\n    return messages.slice(-limit);\n  }\n\n  private getThreadsFallback(userId: string, limit: number): ChatThread[] {\n    const threads = this.fallbackStorage.threads.get(userId) || [];\n    return threads.slice(-limit);\n  }\n\n  private createThreadFallback(threadId: string, userId: string, title: string): void {\n    const userThreads = this.fallbackStorage.threads.get(userId) || [];\n    userThreads.push({\n      threadId,\n      userId,\n      title,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      messageCount: 0\n    });\n    this.fallbackStorage.threads.set(userId, userThreads);\n  }\n\n  private getConversationalContextFallback(userId: string, threadId: string): ConversationMemory | null {\n    return this.fallbackStorage.memory.get(`${userId}_${threadId}`) || null;\n  }\n}\n\nexport const mongoDBChatService = new MongoDBChatService();
